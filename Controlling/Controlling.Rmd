---
title: "Controlling - Forecasting Project"
output: html_notebook
---

Load all libraries and data we need
```{r}
suppressWarnings(library(xts))
suppressWarnings(library(forecast))

candles.xts <- readRDS("DataCMI")
candles.xts$ABC <- NULL
candles.ts <- ts(candles.xts, frequency=5*52)
```

---

Quick overview of the loaded data:
A - "gegossene Kerzen"
B - "gepresste Kerzen"
C - "gezogene Kerzen"
```{r}
boxplot(candles.ts)

plot(candles.xts)
```

---

### Part 1 - Daily - Timeseries forecasting

First, try an automated forecast using the "forecast" package for the next 100 days
```{r}
forecast.ts.auto <- forecast(candles.ts, 100)
plot(forecast.ts.auto)
```

These don't look promising. We can clearly see, that there are more (than one) seasonal components in the sales data (ets can't handle that).
Another try with some more sophisticated timeseries forecasts (tbats)
(see https://robjhyndman.com/hyndsight/dailydata/, ?tbats, De Livera, Hyndman & Snyder (2011), ...)

We use 365.25 as average length of a year (allowing for leap years)
```{r}
model.ts.tbats.A <- tbats(msts(candles.xts$A, seasonal.periods=c(5, 5*4, 5*4*3, 5*52)))
model.ts.tbats.B <- tbats(msts(candles.xts$B, seasonal.periods=c(5, 5*4, 5*4*3, 5*52)))
model.ts.tbats.C <- tbats(msts(candles.xts$C, seasonal.periods=c(5, 5*4, 5*4*3, 5*52)))

forecast.ts.tbats.A <- forecast(model.ts.tbats.A, 5*52)
forecast.ts.tbats.B <- forecast(model.ts.tbats.B, 5*52)
forecast.ts.tbats.C <- forecast(model.ts.tbats.C, 5*52)

plot(forecast.ts.tbats.A)
plot(forecast.ts.tbats.B)
plot(forecast.ts.tbats.C)
```


### Part 2 - Daily - Regression based forecasting

First, add some additional data to the timeseries that we can regress on (year, month, day, ...)
```{r}
candles.xts$year       <- as.factor(format(index(candles.xts),"%Y"))
candles.xts$quarter    <- as.factor(quarters(index(candles.xts)))
candles.xts$month      <- as.factor(format(index(candles.xts),"%m"))
candles.xts$dayOfWeek  <- as.factor(format(index(candles.xts),"%u"))
# candles.xts$dayOfMonth <- format(index(candles.xts),"%d")  # this doesn't seem to have any statistical significance - drop it
# candles.xts$week       <- format(index(candles.xts),"%V")  # this doesn't seem to have any statistical significance - drop it
```



Regress now:
(be careful - if we use year only as a factor, we need to also create that while predicting. Since the model only "learns" about
two factors - year 1 & 2 - we can only manually assume it's going to be more like year 1 or 2. )
```{r}
model.reg.A <- lm(A ~ year + as.factor(quarter) + as.factor(month) + as.factor(dayOfWeek), data=candles.xts)
summary(model.reg.A)
plot(residuals(model.reg.A))

model.reg.B <- lm(B ~ year + as.factor(quarter) + as.factor(month) + as.factor(dayOfWeek), data=candles.xts)
summary(model.reg.B)
plot(residuals(model.reg.B))

model.reg.C <- lm(C ~ year + as.factor(quarter) + as.factor(month) + as.factor(dayOfWeek), data=candles.xts)
summary(model.reg.C)
plot(residuals(model.reg.C))
```

After regressing, build a forecast similar to the timeseries one before
```{r}
# build a planning period (= input data) to forecast on
forecast.reg.xts            <- as.xts(seq(as.Date("2022-01-01"), as.Date("2022-12-31"),by='day'))
forecast.reg.xts$year       <- 3
forecast.reg.xts$quarter    <- as.factor(quarters(index(forecast.reg.xts)))
forecast.reg.xts$month      <- as.factor(format(index(forecast.reg.xts), "%m"))
forecast.reg.xts$dayOfWeek  <- as.factor(format(index(forecast.reg.xts), "%u"))
# exlude saturdays and sundays (since we got no sales there)
forecast.reg.xts            <- subset(forecast.reg.xts, !(forecast.reg.xts$dayOfWeek %in% c(6,7)))

forecast.reg.A <- predict(model.reg.A, forecast.reg.xts, interval = "confidence")
forecast.reg.B <- predict(model.reg.B, forecast.reg.xts, interval = "confidence")
forecast.reg.C <- predict(model.reg.C, forecast.reg.xts, interval = "confidence")

plot(forecast.reg.A[,"fit"], type='l')
plot(forecast.reg.B[,"fit"], type='l')
plot(forecast.reg.C[,"fit"], type='l')

```



### Part 3 - Quarterly - Stochastic process

First we "scale down" our data by reducing the frequency from daily to a quarterly measure.
```{r}
candles.qxts <- apply.quarterly(candles.xts, sum)
colnames(candles.qxts) <- c("ABC")
plot(candles.qxts)
```

We now extract mean and variance of every quarter
```{r}
model.stoch.E  <- matrix(0, 1, 4)   # expected value
model.stoch.SD <- matrix(0, 1, 4)   # standard deviation
model.stoch.CV <- matrix(0, 1, 4)   # coefficient of variation

minCV <- 0.025
model.stoch.SD.corr <- matrix(0, 1, 4)
model.stoch.CV.corr <- matrix(0, 1, 4)

dimnames(model.stoch.E) <- list("ABC", c("Q1","Q2","Q3","Q4"))
dimnames(model.stoch.SD) <- list("ABC", c("Q1","Q2","Q3","Q4"))
dimnames(model.stoch.CV) <- list("ABC", c("Q1","Q2","Q3","Q4"))

dimnames(model.stoch.SD.corr) <- list("ABC", c("Q1","Q2","Q3","Q4"))
dimnames(model.stoch.CV.corr) <- list("ABC", c("Q1","Q2","Q3","Q4"))

for (q in 1:4) {
  model.stoch.E[1,q]  <- mean(candles.qxts[c(q,q+4),])
  model.stoch.SD[1,q] <- sd(candles.qxts[c(q,q+4),])
  model.stoch.CV[1,q] <- model.stoch.SD[1,q] / model.stoch.E[1,q]
}

model.stoch.CV.corr <- model.stoch.CV
model.stoch.CV.corr[model.stoch.CV.corr < minCV] <- minCV
model.stoch.SD.corr <- model.stoch.CV.corr * model.stoch.E
```

Plot some stuff (maybe sales at risk too?)
```{r}
sales <- seq(25000, 70000, length=100)
plot(sales,  dnorm(sales, model.stoch.E[2], model.stoch.SD.corr[2]), col="red", type="l")
lines(sales, dnorm(sales, model.stoch.E[1], model.stoch.SD.corr[1]), col="black")
lines(sales, dnorm(sales, model.stoch.E[3], model.stoch.SD.corr[3]), col="green")
lines(sales, dnorm(sales, model.stoch.E[4], model.stoch.SD.corr[4]), col="blue")
legend("topright", legend=c("Q1","Q2","Q3","Q4"), col=1:4, lty=1)
```









